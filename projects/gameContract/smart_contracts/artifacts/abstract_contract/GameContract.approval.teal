#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "gameType"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/abstract_contract/contract.algo.ts:44
    // gameType = GlobalState<bytes>({ initialValue: Bytes('') })
    bytec_0 // "gameType"
    pushbytes ""
    app_global_put
    // smart_contracts/abstract_contract/contract.algo.ts:49
    // sessionIDCounter = GlobalState<uint64>({ initialValue: 0 })
    pushbytes "sessionIDCounter"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/abstract_contract/contract.algo.ts:38
    // export class GameContract extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@11
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x5683ee08 0xecf339e7 // method "getGameType()byte[]", method "initialize(string)void"
    txna ApplicationArgs 0
    match getGameType initialize
    err

main___algots__.defaultCreate@11:
    // smart_contracts/abstract_contract/contract.algo.ts:38
    // export class GameContract extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts/abstract_contract/contract.algo.ts::GameContract.getGameType[routing]() -> void:
getGameType:
    // smart_contracts/abstract_contract/contract.algo.ts:79
    // return this.gameType.value
    intc_0 // 0
    // smart_contracts/abstract_contract/contract.algo.ts:44
    // gameType = GlobalState<bytes>({ initialValue: Bytes('') })
    bytec_0 // "gameType"
    // smart_contracts/abstract_contract/contract.algo.ts:79
    // return this.gameType.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstract_contract/contract.algo.ts:78
    // public getGameType(): bytes {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/abstract_contract/contract.algo.ts::GameContract.initialize[routing]() -> void:
initialize:
    // smart_contracts/abstract_contract/contract.algo.ts:86
    // public initialize(gameType: string): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/abstract_contract/contract.algo.ts:87
    // assert(this.gameType.value.length === 0, 'Contract already initialized')
    intc_0 // 0
    // smart_contracts/abstract_contract/contract.algo.ts:44
    // gameType = GlobalState<bytes>({ initialValue: Bytes('') })
    bytec_0 // "gameType"
    // smart_contracts/abstract_contract/contract.algo.ts:87
    // assert(this.gameType.value.length === 0, 'Contract already initialized')
    app_global_get_ex
    assert // check GlobalState exists
    len
    !
    assert // Contract already initialized
    // smart_contracts/abstract_contract/contract.algo.ts:88
    // assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/abstract_contract/contract.algo.ts:44
    // gameType = GlobalState<bytes>({ initialValue: Bytes('') })
    bytec_0 // "gameType"
    // smart_contracts/abstract_contract/contract.algo.ts:89
    // this.gameType.value = Bytes(gameType)
    swap
    app_global_put
    // smart_contracts/abstract_contract/contract.algo.ts:86
    // public initialize(gameType: string): void {
    intc_1 // 1
    return
